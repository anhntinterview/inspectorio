import { SerializedError } from '@reduxjs/toolkit';
import { BaseQueryError } from '@reduxjs/toolkit/dist/query/baseQueryTypes';
import {
    MutationSubState,
    RequestStatusFlags,
} from '@reduxjs/toolkit/dist/query/core/apiState';
import { QueryArgFrom } from '@reduxjs/toolkit/dist/query/endpointDefinitions';
import { MutationDefinition } from '@reduxjs/toolkit/dist/query/react';
import { NoInfer } from '@reduxjs/toolkit/dist/query/tsHelpers';

export type UseMutation<T> = (
    options?: UseMutationStateOptions
) => [
    UseMutationTrigger<T>,
    UseMutationResult<T> | SelectedUseMutationResult<any, any>
];

type UseMutationStateOptions = {
    // A method to determine the contents of `UseMutationResult`
    selectFromResult?: (result: UseMutationStateDefaultResult<any>) => any;
    // A string used to enable shared results across hook instances which have the same key
    fixedCacheKey?: string;
};

type UseMutationTrigger<T> = (arg: any) => Promise<
    { data: T } | { error: BaseQueryError<any> | SerializedError }
> & {
    requestId: string; // A string generated by RTK Query
    abort: () => void; // A method to cancel the mutation promise
    unwrap: () => Promise<T>; // A method to unwrap the mutation call and provide the raw response/error
    reset: () => void; // A method to manually unsubscribe from the mutation call and reset the result to the uninitialized state
};

type UseMutationResult<T> = {
    // Base query state
    originalArgs?: unknown; // Arguments passed to the latest mutation call. Not available if using the `fixedCacheKey` option
    data?: T; // Returned result if present
    error?: unknown; // Error result if present
    endpointName?: string; // The name of the given endpoint for the mutation
    fulfilledTimestamp?: number; // Timestamp for when the mutation was completed

    // Derived request status booleans
    isUninitialized: boolean; // Mutation has not been fired yet
    isLoading: boolean; // Mutation has been fired and is awaiting a response
    isSuccess: boolean; // Mutation has data from a successful call
    isError: boolean; // Mutation is currently in an "error" state
    startedTimeStamp?: number; // Timestamp for when the latest mutation was initiated

    reset: () => void; // A method to manually unsubscribe from the mutation call and reset the result to the uninitialized state
};

type UseMutationStateDefaultResult<
    Definition extends MutationDefinition<any, any, any, any>
> = MutationSubState<Definition> & RequestStatusFlags;

type SelectedUseMutationResult<
    D extends MutationDefinition<any, any, any, any>,
    R
> = NoInfer<R> & {
    originalArgs?: QueryArgFrom<D>;
    /**
     * Resets the hook state to it's initial `uninitialized` state.
     * This will also remove the last result from the cache.
     */
    reset: () => void;
};
